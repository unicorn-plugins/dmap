# Skill 표준

> **교차 참조**: 아래 상황에서 추가 문서를 로드할 것.
> - 에이전트를 함께 작성해야 하면 → `standards/plugin-standard-agent.md`
> - 에이전트 이름 규칙(표준 식별자, FQN)이 필요하면 → `standards/plugin-standard-agent.md`의 "에이전트 이름 규칙"
> - Gateway 매핑이 필요하면 → `standards/plugin-standard-gateway.md`
> - 전체 아키텍처 확인이 필요하면 → `standards/plugin-standard.md`

---

## 한 줄 정의

SKILL.md는 사용자 요청을 라우팅하고 에이전트 워크플로우를 오케스트레이션(위임형)하거나
Gateway 도구를 직접 사용(직결형)하는 Controller+UseCase 레이어의 프롬프트 지시문임.

[Top](#skill-표준)

---

## SKILL.md 구조

### Frontmatter 필드

| 필드 | 필수 | 설명 | 예시 |
|------|------|------|------|
| `name` | ✅ | 스킬 ID (kebab-case) | `my-skill` |
| `description` | ✅ | 한 줄 설명 | `코드 품질 분석 스킬` |
| `user-invocable` | 선택 | 사용자 직접 호출 가능 여부 (기본값: true) | `true` |
| `disable-model-invocation` | 선택 | 런타임 자동 호출 차단 (Setup 스킬용) | `true` |
| `allowed-tools` | 선택 | 허용 도구 목록 | `["Read", "Task"]` |
| `model` | 선택 | 기본 모델 | `sonnet` |
| `context` | 선택 | 컨텍스트 힌트 | `["code-quality"]` |
| `agent` | 선택 | 전용 에이전트 ID | `architect` |

### Markdown Content 골격

```markdown
# {스킬명}

[{스킬명} 활성화]                    ← 선택 (스킬 시작 시 화면에 출력하는 메시지)

## 목표                              ← 필수
(이 스킬이 달성하려는 핵심 목적 1~2문장)

## 활성화 조건                       ← 권장
(이 스킬이 활성화되는 조건)

## 워크플로우                        ← 권장
(단계별 접근법)

### Step 1: 분석                     ← 일반 단계 (위임 없음)
(스킬이 직접 수행하는 작업)

### Step 2: 구현 → Agent: executor   ← Agent 위임 단계 (5항목 필수)
- **TASK**: ...
- **EXPECTED OUTCOME**: ...
- **MUST DO**: ...
- **MUST NOT DO**: ...
- **CONTEXT**: ...

### Step 3: 모드 전환 → Skill: ralph ← Skill 위임 단계 (3항목 필수)
- **INTENT**: ...
- **ARGS**: ...
- **RETURN**: ...
```

[Top](#skill-표준)

---

## 스킬 유형 분류

스킬은 역할에 따라 5가지 유형으로 분류됨.
각 유형은 공통 골격 위에 고유 섹션을 추가하여 정체성을 형성하며, 실행 경로(위임형/직결형)가 유형별로 결정됨.

| 유형 | 영문명 | 실행 경로 | 역할 | 예시 |
|------|--------|----------|------|------|
| 핵심스킬 | Core | 위임형 | 시스템 전체 행동 규범 정의, 항상 활성화 | core |
| 설정스킬 | Setup | 직결형 | 설치 · 설정 마법사 제공 | omc-setup, mcp-setup |
| 계획스킬 | Planning | 위임형 | 전략적 계획 수립 · 검토 | plan, ralplan, review |
| 지휘자스킬 | Orchestrator | 위임형 | 워크플로우 조율, 병렬 실행, 분석, 리뷰 | autopilot, ralph, analyze, tdd |
| 유틸리티스킬 | Utility | 직결형 | 보조 기능, 상태 제어, 도구, 헬퍼 | note, doctor, help, cancel |

### 스킬 실행 경로

스킬은 유형에 따라 두 가지 실행 경로 중 하나를 따름.

| 실행 경로 | 의미 | 해당 유형 | Agent 계층 |
|----------|------|----------|-----------|
| **위임형** | LLM 추론·자율 판단이 필요한 작업 → Agent에 위임 | Core, Planning, Orchestrator | 경유 (필수) |
| **직결형** | 절차적·결정론적 작업 → Gateway 도구 직접 사용 | Setup, Utility | 생략 |

```
위임형:  Skill(Controller) → Agent(Service) → Gateway
직결형:  Skill(Controller) ──────────────────→ Gateway  (Service 생략)
```

**직결형이 필요한 이유 — YAGNI (You Aren't Gonna Need It):**
- Setup/Utility 스킬은 설정 파일 작성, 상태 확인, 도구 설치 등 **결정론적 작업**을 수행
- 이런 작업에 Agent를 경유하면 불필요한 LLM 호출이 발생 (오버 아키텍처링)
- XP(Extreme Programming)의 YAGNI 원칙: "지금 필요하지 않은 기능은 만들지 않는다"
- Agent 계층이 제공하는 자율적 추론은 직결형 스킬에 **필요하지 않은 기능**임

**직결형 스킬의 제약:**
- 애플리케이션 코드 작성·수정은 여전히 금지 — 코드 작업은 반드시 위임형 경로 사용
- 직결형은 설정 파일, 상태 파일, 문서 등 **인프라성 파일**에만 직접 접근

[Top](#skill-표준)

---

## 스킬 활성화의 3계층 구조

스킬이 활성화되기까지 세 가지 계층이 관여함.
각 계층은 역할이 다르며, 모두 필요하지만 목적이 분리됨.

### 런타임 상주 파일 — 라우팅 테이블 (항상 로드)

런타임 상주 파일은 런타임이 세션 시작 시 항상 읽는 파일임.
사용자 요청이 어떤 플러그인의 어떤 스킬과 매칭되는지를 선언하는 라우팅 테이블을 포함함.
setup 스킬이 플러그인 설치 시 이 라우팅 테이블을 런타임 상주 파일에 추가함.

> **런타임별 상주 파일**: Claude Code → `CLAUDE.md`, Codex CLI → `AGENTS.md` 등 런타임마다 다름.

예: `"코드 품질 분석 요청" → code-quality 플러그인 → core 스킬`

### 핵심 스킬 — 오케스트레이션 실행 (조건 매칭 시 로드)

핵심 스킬(예: `core`)은 라우팅에 의해 활성화된 후 실제 오케스트레이션을 수행함.
Gateway의 `runtime-mapping.yaml`을 참조하여 매핑을 해석하고 에이전트를 스폰(생성·초기화)함.

### 순환 의존 문제 해결

활성화 조건이 핵심 스킬 안에만 있으면 스킬을 로드하기 위해 조건을 먼저 알아야 하는 순환 문제가 발생함.
따라서 라우팅 테이블은 런타임 상주 파일에 분리함.

[Top](#skill-표준)

---

## 역할 경계 요약

스킬은 **라우터(Router)와 오케스트레이터(Orchestrator)** 역할에 집중함.
직접 작업을 수행하는 것이 아니라, 요청을 분석하고 적절한 에이전트에게 위임하는 것이 핵심 역할임.

| 스킬이 직접 수행 | 에이전트에 위임 (Task 도구) | 다른 스킬에 위임 (Skill 도구) |
|------------------|---------------------------|-------------------------------|
| 요청 의도 분류 (라우팅) | 코드 작성·수정 | 다른 워크플로우 전환 (모드 변경) |
| 워크플로우 분기 결정 | 탐색·분석·조사 | 하위 기능 호출 (setup → hud 등) |
| 사용자 상호작용 (질문, 안내) | 문서 작성 | 독립 스킬의 워크플로우 재활용 |
| 상태 관리 (진행률, 반복 카운트) | 검증·테스트 | 진입점 위임 (commands → skill) |
| 에이전트 결과 취합·보고 | 설계·아키텍처 결정 | — |

> **직결형 스킬 예외**: Setup과 Utility 유형은 직결형 실행 경로를 따르므로,
> 에이전트 위임 없이 Gateway 도구(Read, Write, Bash 등)를 직접 사용함.
> 위 테이블의 "에이전트에 위임" 열은 위임형 스킬(Core, Planning, Orchestrator)에만 적용.

### 위임 대상 판단 기준

| 상황 | 위임 대상 | 도구 | 이유 |
|------|----------|------|------|
| 단일 작업 실행 (코드 작성, 분석 등) | Agent | `Task` | 에이전트가 자율적으로 완수 |
| 다른 워크플로우로 전환 (모드 변경 등) | Skill | `Skill` | 스킬만이 오케스트레이션 로직 보유 |
| 하위 기능 호출 (setup → hud 등) | Skill | `Skill` | 독립된 스킬의 전체 워크플로우 재활용 |
| 사용자 요청 전달 (commands → skill) | Skill | `Skill` | 얇은 wrapper 진입점 |

### 프롬프트 깊이 차등화

스킬이 직접 수행하는 영역과 에이전트에 위임하는 영역은 **프롬프트 작성의 깊이**가 달라야 함:

| 영역 | 프롬프트 깊이 | 작성 지침 |
|------|-------------|-----------|
| **라우팅/분기 로직** | **상세** | 의도 분류 기준, 조건별 분기, 모드 전환 로직을 빠짐없이 기술 |
| **사용자 상호작용** | **상세** | 질문 형식, 응답 처리, 오류 안내 등 UX 흐름을 구체적으로 정의 |
| **에이전트 위임 지시** | **간결** | 목표(WHAT)와 제약(MUST NOT)만 명시, 방법(HOW)은 에이전트에 위임 |
| **상태 관리** | **중간** | 상태 파일 경로·구조는 명시, 세부 로직은 간결하게 |

**핵심**: 스킬 프롬프트가 에이전트의 작업 방법까지 상세히 기술하면 에이전트의 자율성이 떨어지고
유지보수 비용이 증가함. **"무엇을 달성할 것인가"**에 집중하고, **"어떻게 달성할 것인가"**는 에이전트에 맡김.

### 위임 표기법 (Delegation Notation)

워크플로우 단계에서 Agent 또는 Skill에 위임할 때, **단계 제목에 마커**를 붙여 위임을 선언함.
마커가 있는 단계는 해당 위임 유형의 필수 항목을 본문에 반드시 포함해야 함.

**마커 형식:**

| 마커 | 의미 | 필수 항목 | 도구 |
|------|------|----------|------|
| `→ Agent: {name}` | Agent에 작업 위임 | 5항목 | Task |
| `→ Skill: {name}` | 다른 Skill에 위임 | 3항목 | Skill |

#### Agent 위임 5항목 (`→ Agent:`)

```
- **TASK**: 원자적이고 구체적인 목표 (하나의 작업당 하나의 위임)
- **EXPECTED OUTCOME**: 구체적 산출물과 성공 기준
- **MUST DO**: 반드시 수행해야 할 요건 — 빠짐없이 나열
- **MUST NOT DO**: 금지 행위 — 에이전트의 월권 방지
- **CONTEXT**: 파일 경로, 기존 패턴, 제약 조건
```

**간결 원칙**: 위 5항목 외에 에이전트의 내부 사고 방식이나 단계별 절차는 기술하지 않음.
에이전트는 자신의 AGENT.md에 정의된 역할과 워크플로우를 따름.

#### Skill 위임 3항목 (`→ Skill:`)

```
- **INTENT**: 호출 목적 (왜 이 스킬을 호출하는지)
- **ARGS**: 전달 인자 (사용자 입력, 선행 결과 등)
- **RETURN**: 호출 후 기대하는 상태 또는 복귀 조건
```

대상 스킬이 **이미 자체 워크플로우를 보유**하므로, Agent 위임보다 전달 항목이 간결함.

#### 워크플로우 적용 예시

```markdown
## 워크플로우

### Step 1: 요청 분석
사용자 요청의 의도를 분류하고 작업 범위를 결정함.

### Step 2: 코드 탐색 → Agent: explorer
- **TASK**: 대상 모듈의 현재 구조와 의존관계 파악
- **EXPECTED OUTCOME**: 파일 목록, 의존 관계, 수정 영향 범위 보고서
- **MUST DO**: 테스트 파일 포함하여 탐색
- **MUST NOT DO**: 코드 수정 금지
- **CONTEXT**: `src/` 디렉토리 대상

### Step 3: 구현 → Agent: executor
- **TASK**: Step 2의 분석 결과를 기반으로 기능 구현
- **EXPECTED OUTCOME**: 컴파일 에러 없는 구현 코드
- **MUST DO**: 기존 패턴과 일관성 유지
- **MUST NOT DO**: 요청 범위 외 리팩터링 금지
- **CONTEXT**: Step 2의 탐색 결과 참조

### Step 4: QA 전환 → Skill: ultraqa
- **INTENT**: 구현 완료 후 QA 사이클 진입
- **ARGS**: 구현된 파일 목록, 테스트 대상
- **RETURN**: 모든 테스트 통과 시 완료
```

#### Skill→Skill 위임 패턴 분류

| 패턴 | 설명 | 예시 |
|------|------|------|
| **하위 기능 호출** | 자기 워크플로우 중 다른 스킬의 기능을 부분적으로 사용 | setup → hud, setup → mcp-setup |
| **모드 전환** | 오케스트레이터가 실행 중 다른 오케스트레이터로 전환 | autopilot → ralph, autopilot → ultraqa |
| **진입점 위임** | commands가 Skill 도구로 스킬에 위임 (얇은 wrapper) | commands/setup.md → abra:setup |

#### Agent 위임과 Skill 위임 비교

| 항목 | `→ Agent:` (Task 도구) | `→ Skill:` (Skill 도구) |
|------|------------------------|--------------------------|
| 필수 항목 | 5항목 | 3항목 |
| HOW 지정 | 금지 (에이전트 자율) | 불필요 (대상 스킬이 자체 워크플로우 보유) |
| 실행 주체 | 서브에이전트로 스폰 | 현재 컨텍스트에서 스킬 로드 |
| 결과 반환 | 에이전트가 결과 텍스트 반환 | 스킬 워크플로우 완료 후 흐름 복귀 |

[Top](#skill-표준)

---

## 에이전트 호출 규칙

위임형 스킬이 `Task` 도구로 에이전트를 호출할 때의 규칙.

### 에이전트 탐색·스폰 흐름

```
1. agents/{agent-name}/ 디렉토리에서 3파일 로드
   ├── AGENT.md       → 프롬프트 본문
   ├── agentcard.yaml → tier 확인 + 프롬프트에 첨부
   └── tools.yaml     → 도구 해석 + 프롬프트에 첨부
2. tier → runtime-mapping.yaml로 모델 매핑
3. 프롬프트 조립: AGENT.md + agentcard.yaml + tools.yaml
4. Task(subagent_type=FQN, model=매핑된모델, prompt=조립된 프롬프트) 호출
```

> **프롬프트 조립**: AGENT.md의 "참조" 섹션이 agentcard.yaml과 tools.yaml을 참조하도록 지시하므로,
> 위임형 스킬은 3파일을 합쳐 하나의 프롬프트로 전달함. 에이전트는 자신의 역할·제약·도구를 모두 인식함.

> **매핑 참조**: 위임형 스킬은 `gateway/runtime-mapping.yaml`을 참조하여 tier→모델 매핑을 수행함.
> 에이전트는 runtime-mapping.yaml을 직접 참조하지 않음 — 인프라 매핑은 스킬(Controller)의 책임.

### FQN (정규화된 이름)

런타임이 `agents/` 디렉토리를 재귀 탐색하여 자동 생성하는 전체 이름.

| 형식 | 예시 |
|------|------|
| `{plugin}:{디렉토리명}:{frontmatter-name}` | `abra:architect:architect` |

### 호출 예시

```python
# 위임형 스킬에서 에이전트 호출 예시
Task(
    subagent_type="abra:architect:architect",
    model="opus",        # tier: HIGH → runtime-mapping.yaml에서 매핑
    prompt="시스템 아키텍처를 분석해주세요..."
)
```

> **상세 규칙**: 에이전트 이름 규칙의 전체 내용은 → `standards/plugin-standard-agent.md`의 "에이전트 이름 규칙" 참조.

[Top](#skill-표준)

---

## 공통 필수 섹션

모든 스킬이 포함해야 할 기본 골격:

| 순서 | 표준 섹션명 | 필수 | 설명 |
|------|------------|------|------|
| 1 | `# {스킬명}` | ✅ | H1 타이틀 + 역할 요약 (한 줄) |
| 2 | `[{스킬명} 활성화]` | 선택 | 스킬 시작 시 화면에 출력하는 메시지 |
| 3 | `## 목표` | ✅ | 이 스킬이 달성하려는 핵심 목적 |
| 4 | `## 활성화 조건` | 권장 | 이 스킬이 활성화되는 조건 · 상황 (자기 선언) |
| 5 | `## 워크플로우` | 권장 | 워크플로우 / 단계별 접근법. 위임 시 `→ Agent:` 또는 `→ Skill:` 마커 사용 |

### 섹션명 통일 규칙

동일 목적의 섹션은 표준명 사용 권장:

| 목적 | 표준명 | 비권장 (혼용 사례) |
|------|--------|-------------------|
| 핵심 목적 | `## 목표` | Overview, What It Does, Core Concept, 개요 |
| 활성화 조건 | `## 활성화 조건` | Activation, When to Use, Magic Keywords |
| 워크플로우 | `## 워크플로우` | Workflow, Phases, Approach, Step N |

### 유형별 활성화 조건 작성 가이드

| 유형 | 활성화 조건 내용 | 예시 |
|------|-----------------|------|
| Core | 광범위 조건 매칭 시 자동 활성화 | "위임이 필요한 작업 감지 시 활성화" |
| Setup | 명시적 호출만 (`/command`) | "사용자가 `/omc-setup` 호출 시" |
| Planning | 키워드 감지 또는 명시적 호출 | "broad request 감지 시 또는 `/plan` 호출 시" |
| Orchestrator | 키워드 감지 + 매직 키워드 | "autopilot, build me, analyze 키워드 감지 시" |
| Utility | 명시적 호출 또는 키워드 감지 | "사용자가 `/note` 호출 시, cancelomc 키워드 감지 시" |

[Top](#skill-표준)

---

## 유형별 필수/권장 섹션

### Core (핵심스킬)

항상 활성화되어 시스템 전체 행동 규범을 정의하는 스킬.

#### 고유 섹션

공통 골격(`# {스킬명}`, `## 목표`, `## 워크플로우` 등)에 더해 Core 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 작업 관리` | 권장 | 작업 관리 규칙 (Todo 생성 기준, 워크플로우) |
| `## 어조와 스타일` | 권장 | 커뮤니케이션 스타일 (간결성, 사용자 맞춤) |
| `## 제약 사항` | 권장 | 소프트 가이드라인 (기존 라이브러리 선호 등) |

#### 워크플로우 작성 패턴

Core 스킬의 `## 워크플로우`는 **라우팅 전용**으로 구성됨.
매 메시지마다 요청 의도를 감지하고 적절한 스킬로 분배하는 흐름을 정의함.

**라우팅 워크플로우 구성:**

| 단계 | 이름 | 설명 |
|------|------|------|
| **Step 1** | 의도 감지 (Intent Detection) | 요청을 분류하는 규칙 정의 (키워드 매칭, 패턴 분석 등) |
| **Step 2** | 스킬 매칭 (Skill Matching) | 분류된 의도를 어떤 스킬에 라우팅할지 조건 테이블로 정의 |
| **Step 3** | 위임 (Dispatch) | 매칭된 스킬에 `→ Skill:` 마커로 위임. 미매칭 시 기본 동작 정의 |

> **Core ≠ Orchestrator**: 실행(현황 파악, 에이전트 위임, 검증, 완료)은 Orchestrator 스킬의 역할.
> Core는 라우팅까지만 수행하고 실행 흐름을 위임된 스킬에 넘김.

#### 특징

- 활성화 조건에 매칭 시 **자동 활성화**
- `{{PROMPT}}` 치환 없음 — 항상 적용되는 행동 규범

[Top](#skill-표준)

---

### Setup (설정스킬)

설치 · 설정 마법사를 제공하는 직결형 스킬.
Agent 위임 없이 Gateway 도구(Bash, Write 등)를 직접 사용.

#### 고유 섹션

공통 골격에 더해 Setup 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 사용자 상호작용` | ✅ | AskUserQuestion으로 사용자 선택지를 UI로 제공하여 분기 |
| `## 스킬 위임` | 권장 | `Skill tool`로 다른 스킬 호출 (예: setup → hud) |
| `## 상태 관리` | 권장 | 상태 파일 기반 중단/재개 복원 |
| `## 문제 해결` | 권장 | 설치 문제 해결 안내 |

#### 워크플로우 작성 패턴

Setup 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.
사용자가 진행 상황을 파악하기 쉽도록 단계별 번호를 부여함.

#### 특징

- bash 명령어(설치) + Write 도구(설정 파일 작성) 혼합 사용
- 설정 완료 후 검증 단계 포함 권장

#### frontmatter 권장 설정

```yaml
---
name: setup
description: 플러그인 초기 설정
user-invocable: true
disable-model-invocation: true    # 사용자 명시적 호출만 허용
---
```

setup 스킬은 `disable-model-invocation: true`로 설정하여 런타임이 자동 호출하지 않도록 해야 함.
사용자가 `/my-plugin:setup`으로 명시적으로 호출할 때만 실행됨.

[Top](#skill-표준)

---

### Planning (계획스킬)

전략적 계획 수립 · 검토를 담당하는 스킬.

#### 고유 섹션

공통 골격에 더해 Planning 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 에이전트 호출 규칙` | ✅ | 에이전트 FQN, 프롬프트 조립, 모델·툴·금지액션 구체화 규칙 |
| `## 품질 기준` | 권장 | 계획 품질 기준 (참조율, 실현 가능성 등) |
| `## 판정 기준` | 권장 | 승인 / 수정 요청 / 반려 판정 기준 |
| `## 계획 저장` | 권장 | 계획 파일 저장 위치 |
| `## 외부 모델 검증` | 선택 | 외부 모델 크로스 검증 프로토콜 |

#### 에이전트 호출 규칙 작성 가이드

`## 에이전트 호출 규칙` 섹션에 다음 내용을 포함할 것:

1. **에이전트 FQN 목록** — 이 스킬이 호출하는 에이전트의 FQN (`{plugin}:{agent}:{agent}`)
2. **프롬프트 조립 절차**:
   - `agents/{agent-name}/` 에서 3파일 로드 (AGENT.md + agentcard.yaml + tools.yaml)
   - `gateway/runtime-mapping.yaml` 참조하여 구체화:
     - **모델 구체화**: agentcard.yaml의 `tier` → `tier_mapping`에서 모델 결정
     - **툴 구체화**: tools.yaml의 추상 도구 → `tool_mapping`에서 실제 도구 결정
     - **금지액션 구체화**: agentcard.yaml의 `forbidden_actions` → `action_mapping`에서 제외할 실제 도구 결정
     - **최종 도구** = (구체화된 도구) - (제외 도구)
   - 3파일을 합쳐 하나의 프롬프트로 조립
   - `Task(subagent_type=FQN, model=구체화된 모델, prompt=조립된 프롬프트)` 호출

#### 워크플로우 작성 패턴

Planning 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.

#### 계획 모드 (Planning Mode)

Planning 스킬은 요구사항의 명확도에 따라 세 가지 모드 중 하나로 동작함.
이 모드는 Planning 유형에 한정하지 않고, 사용자 입력을 받아 계획을 수립하는 **모든 스킬**에 적용 가능한 패턴임.

| 모드 | 활성화 조건 | 진행 방식 | 적합한 상황 |
|------|------------|-----------|------------|
| **Interview** | 요구사항이 모호하거나 광범위 (기본값) | 사용자에게 **한 번에 한 질문**씩 순차 질의하여 요구사항 구체화 | "개선해 줘", "리팩터링해 줘" 등 대상·범위가 불명확한 요청 |
| **Direct** | 요구사항이 충분히 구체적 | 인터뷰 생략, **즉시 계획 생성** | 파일·함수·범위가 명시된 상세 요청, `--direct` 플래그 |
| **Consensus** | 복수 관점의 검증이 필요한 복잡한 과제 | 복수 에이전트(예: Planner + Architect + Critic)가 **반복 합의** → 최대 N회 | 아키텍처 결정, 대규모 리팩터링, `--consensus` 플래그 |

각 모드의 핵심 메커니즘:

| 모드 | 핵심 메커니즘 | OMC 참조 구현 |
|------|-------------|--------------|
| **Interview** | AskUserQuestion 도구로 한 번에 한 질문, 질문 전 에이전트로 팩트 선행 조사 (적응형 탐색) | `plan` 스킬 (interview 모드) |
| **Direct** | 주어진 요구사항만으로 계획 생성, 사용자 상호작용 최소화 | `plan --direct` |
| **Consensus** | 에이전트 간 제안 → 검토 → 수정 루프를 합의 도달 시까지 반복 | `ralplan` (`plan --consensus`) |

**모드 선택 가이드**: 요구사항 명확도를 기준으로 자동 판별하되, 사용자가 플래그(`--direct`, `--consensus`)로
명시적 지정도 가능하게 설계함.

[Top](#skill-표준)

---

### Orchestrator (지휘자스킬)

워크플로우 조율, 병렬 실행, 전문 분석·리뷰를 관리하는 위임형 스킬.
기존 수행자스킬(Executor)의 역할(분석, 리뷰, TDD 등 단일 목적 오케스트레이션)을 포함.

#### 고유 섹션

공통 골격에 더해 Orchestrator 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 에이전트 호출 규칙` | ✅ | 에이전트 FQN, 프롬프트 조립, 모델·툴·금지액션 구체화 규칙 |
| `## 완료 조건` | ✅ | 완료 조건 목록 (기능 동작, 검증 통과, 에러 0 등) |
| `## 검증 프로토콜` | ✅ | 검증 절차 — 완료 전 검증자 승인 강제 |
| `## 상태 정리` | ✅ | 상태 파일 정리 규칙 (완료 시 삭제) |
| `## 취소` / `## 재개` | ✅ | 취소 및 재개 메커니즘 |
| `## 출력 형식` | 권장 | 보고서/출력 텍스트 템플릿 (분석·리뷰 오케스트레이터용) |
| `## 체크리스트` | 선택 | 카테고리별 `- [ ]` 형식 검토 항목 |

#### 에이전트 호출 규칙 작성 가이드

`## 에이전트 호출 규칙` 섹션에 다음 내용을 포함할 것:

1. **에이전트 FQN 목록** — 이 스킬이 호출하는 에이전트의 FQN (`{plugin}:{agent}:{agent}`)
2. **프롬프트 조립 절차**:
   - `agents/{agent-name}/` 에서 3파일 로드 (AGENT.md + agentcard.yaml + tools.yaml)
   - `gateway/runtime-mapping.yaml` 참조하여 구체화:
     - **모델 구체화**: agentcard.yaml의 `tier` → `tier_mapping`에서 모델 결정
     - **툴 구체화**: tools.yaml의 추상 도구 → `tool_mapping`에서 실제 도구 결정
     - **금지액션 구체화**: agentcard.yaml의 `forbidden_actions` → `action_mapping`에서 제외할 실제 도구 결정
     - **최종 도구** = (구체화된 도구) - (제외 도구)
   - 3파일을 합쳐 하나의 프롬프트로 조립
   - `Task(subagent_type=FQN, model=구체화된 모델, prompt=조립된 프롬프트)` 호출

#### 워크플로우 작성 패턴

Orchestrator 스킬은 `## 워크플로우` 안에 `### Phase N: {Name}` 패턴으로 순차/병렬 단계를 정의함.
각 Phase는 Goal → Agents → Output 구조를 따름.

#### 특징

- 가장 풍부한 구조 (평균 10+ 섹션)
- 검증 프로토콜(Iron Law): "검증 없이 완료 선언 불가" 원칙
- 모드 간 계층 관계 존재 (예: autopilot → ralph → ultrawork)
- 독립 실행 가능 스킬 vs 컴포넌트(단독 불가) 구분

[Top](#skill-표준)

---

### Utility (유틸리티스킬)

보조 기능, 상태 제어, 도구, 헬퍼, 문서화 등을 제공하는 직결형 스킬.
기존 감독자스킬(Supervisor)의 역할(상태 감시·제어)을 포함.

#### 고유 섹션

공통 골격에 더해 Utility 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 명령어` | ✅ | 명령어 또는 하위 명령어 테이블 |
| `## 참고사항` | 선택 | 필요 시 자유 형식으로 기술 (자동 감지, 연동, 파일 구조, 스키마, 보존 정책 등) |

#### 워크플로우 작성 패턴

Utility 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.

#### 실행 경로

직결형: Gateway 도구(Bash, Read, Write 등)를 직접 사용. Agent 위임 없음.
상태 제어 유틸리티(예: cancel)는 상태 파일 읽기 → 조건 판단 → 파일 삭제/명령 실행의 절차적 흐름.

#### 특징

- **직결형 실행** — Agent 계층을 거치지 않고 Gateway 도구 직접 사용 (YAGNI)
- 가장 간결한 구조 (평균 5 섹션)
- 테이블 중심: 명령어, 옵션, 서브커맨드를 테이블로 정리
- 도메인 특화 가능: 창작, 환경 관리, 배포, 상태 제어 등

[Top](#skill-표준)

---

## 공통 선택 섹션

복잡도에 따라 선택적으로 추가:

| 섹션 | 권장 시기 | 설명 |
|------|-----------|------|
| `## 외부 모델 검증` | 외부 AI 모델 활용 시 | Codex, Gemini 등 크로스 검증 프로토콜 |
| `## 문제 해결` | 실패 가능성 높은 스킬 | 문제 해결 안내 |
| `## 예시` | 복잡한 사용법 스킬 | 시나리오별 사용 예시 |
| `## 모범 사례` | 오용 가능성 있는 스킬 | 모범 사례 / 안티패턴 |
| `## 아키텍처` | 복잡한 시스템 스킬 | ASCII 아키텍처 다이어그램 |
| `## 상태 관리` | 상태 파일 사용 스킬 | 상태 파일 위치 + JSON 구조 |
| `## 매직 키워드` | 자동 활성화 지원 스킬 | 트리거 키워드 목록 |
| `## 에러 처리` | 실패 복구 필요 스킬 | 에러 유형별 대응 전략 |

[Top](#skill-표준)

---

## 표준 템플릿

### Core 유형 템플릿

```markdown
---
name: my-core-skill
description: 시스템 전체 행동 규범
---

# My Core Skill

[MY-CORE-SKILL 활성화]

## 목표

시스템 전체에 항상 적용되는 행동 규범을 정의함.

## 활성화 조건

광범위 조건 매칭 시 자동 활성화.

## 워크플로우

### Step 1: 의도 감지

요청의 키워드, 패턴, 맥락을 분석하여 의도를 분류함.

### Step 2: 스킬 매칭

| 의도 | 매칭 스킬 |
|------|----------|
| "build me", "autopilot" | autopilot |
| "plan this", broad request | plan |
| ... | ... |

### Step 3: 위임 → Skill: {매칭된 스킬}

- **INTENT**: 분류된 의도에 맞는 스킬 활성화
- **ARGS**: 사용자 요청 원문 전달
- **RETURN**: 스킬 워크플로우 완료 후 사용자에게 결과 보고

미매칭 시 기본 Orchestrator로 라우팅.

## 작업 관리

Todo 생성 기준 및 워크플로우.

## 어조와 스타일

커뮤니케이션 스타일 (간결성, 사용자 맞춤).

## 제약 사항

소프트 가이드라인 (기존 라이브러리 선호 등).
```

### Orchestrator 유형 템플릿

```markdown
---
name: my-orchestrator
description: 워크플로우 조율 및 병렬 실행 관리
---

# My Orchestrator

[MY-ORCHESTRATOR 활성화]

## 목표

워크플로우 조율 및 병렬 실행을 관리하는 지휘자 스킬.

## 활성화 조건

"keyword" 키워드 감지 시 또는 `/my-orchestrator` 호출 시.

## 에이전트 호출 규칙

### 에이전트 FQN

| 에이전트 | FQN |
|----------|-----|
| executor | `my-plugin:executor:executor` |
| architect | `my-plugin:architect:architect` |

### 프롬프트 조립

1. `agents/{agent-name}/` 에서 3파일 로드 (AGENT.md + agentcard.yaml + tools.yaml)
2. `gateway/runtime-mapping.yaml` 참조하여 구체화:
   - **모델 구체화**: agentcard.yaml의 `tier` → `tier_mapping`에서 모델 결정
   - **툴 구체화**: tools.yaml의 추상 도구 → `tool_mapping`에서 실제 도구 결정
   - **금지액션 구체화**: agentcard.yaml의 `forbidden_actions` → `action_mapping`에서 제외할 실제 도구 결정
   - **최종 도구** = (구체화된 도구) - (제외 도구)
3. 프롬프트 조립: AGENT.md + agentcard.yaml + tools.yaml을 합쳐 하나의 프롬프트로 구성
4. `Task(subagent_type=FQN, model=구체화된 모델, prompt=조립된 프롬프트)` 호출

## 워크플로우

### Phase 1: 초기화

상태 파일 생성, 설정 로드.

### Phase 2: 실행 → Agent: executor

- **TASK**: 기능 구현
- **EXPECTED OUTCOME**: 컴파일 에러 없는 구현 코드
- **MUST DO**: 기존 패턴 일관성 유지
- **MUST NOT DO**: 요청 범위 외 수정 금지
- **CONTEXT**: Phase 1에서 로드한 설정 참조

### Phase 3: 검증 → Agent: architect

- **TASK**: 구현 결과 검증
- **EXPECTED OUTCOME**: 승인(APPROVED) 또는 수정 요청(REJECTED + 사유)
- **MUST DO**: 빌드·테스트 통과 확인, 코드 품질 검토
- **MUST NOT DO**: 직접 코드 수정 금지
- **CONTEXT**: Phase 2 구현 결과물

### Phase 4: 완료

상태 정리 및 사용자 보고.

## 완료 조건

- [ ] 기능 동작 확인
- [ ] 검증 통과
- [ ] 에러 0

## 검증 프로토콜

완료 전 Architect 승인 필수.

## 상태 정리

완료 시 `.omc/state/my-orchestrator-state.json` 삭제.

## 취소

`cancelomc` 또는 `stopomc` 키워드로 취소.

## 재개

`resume-session` 도구로 재개 가능.
```

[Top](#skill-표준)

---

## MUST 규칙

| # | 규칙 | 근거 |
|---|------|------|
| 1 | YAML Frontmatter(name, description) + Markdown Content 구조 유지 | 메타데이터/프롬프트 분리 |
| 2 | H1 타이틀 + 목표 + 활성화 조건 공통 골격 포함 | 스킬 간 일관성 |
| 3 | 에이전트 위임 시 WHAT+제약만 명시, HOW는 에이전트에 맡김 | 에이전트 자율성 보장 |
| 4 | 워크플로우에서 `→ Agent:` 마커 사용 시 5항목, `→ Skill:` 마커 사용 시 3항목 포함 | 위임 품질 보장 |
| 5 | 라우팅/분기 로직은 상세히, 에이전트 위임은 간결하게 | 프롬프트 깊이 차등화 |
| 6 | 섹션명 한글 표준명 사용 (목표, 활성화 조건, 워크플로우) | 스킬 간 일관성 |

[Top](#skill-표준)

---

## MUST NOT 규칙

| # | 금지 사항 | 이유 |
|---|----------|------|
| 1 | 스킬이 직접 애플리케이션 코드 작성·수정·삭제 (직결형 스킬의 설정 파일·문서 작업은 예외) | 에이전트 역할 침범 |
| 2 | 에이전트 위임 시 내부 사고 방식·단계별 절차 기술 | 에이전트 자율성 저해 |
| 3 | `→ Agent:` 위임 시 5항목, `→ Skill:` 위임 시 3항목 외 추가 기술 | 간결 원칙 위반 |
| 4 | 비표준 섹션명 사용 (Overview 대신 목표 사용) | 일관성 저해 |

[Top](#skill-표준)

---

## 검증 체크리스트

- [ ] Frontmatter에 name, description 포함
- [ ] H1 타이틀 존재
- [ ] 목표 섹션 존재
- [ ] 유형에 맞는 고유 섹션 포함
- [ ] 실행 경로가 유형에 맞는가 (위임형: Core/Planning/Orchestrator, 직결형: Setup/Utility)
- [ ] 위임형 스킬: `→ Agent:` 마커가 있는 워크플로우 단계에 5항목이 포함되는가
- [ ] 위임형 스킬: `→ Skill:` 마커가 있는 워크플로우 단계에 3항목이 포함되는가
- [ ] 직결형 스킬: Agent 위임 없이 Gateway 도구를 직접 사용하는가 (YAGNI)
- [ ] 직결형 스킬: 애플리케이션 코드 작성·수정을 하지 않는가 (설정 파일·문서만 허용)
- [ ] 위임 프롬프트에 HOW(방법) 없이 WHAT(목표)+제약만 기술했는가
- [ ] 라우팅 로직은 상세하게, 위임은 간결하게 작성했는가
- [ ] Core 스킬: 워크플로우가 라우팅 전용인가 (실행 Phase 없음)
- [ ] Setup 스킬: `disable-model-invocation: true` 설정했는가
- [ ] 섹션명이 한글 표준명을 사용하는가 (목표, 활성화 조건, 워크플로우)
- [ ] commands/ 진입점 파일 작성 (슬래시 명령 노출 시)

[Top](#skill-표준)
