# Skill 표준

> **교차 참조**: 아래 상황에서 추가 문서를 로드할 것.
> - 에이전트를 함께 작성해야 하면 → `standards/plugin-standard-agent.md`
> - 에이전트 이름 규칙(표준 식별자, FQN)이 필요하면 → `standards/plugin-standard-agent.md`의 "에이전트 이름 규칙"
> - Gateway 매핑이 필요하면 → `standards/plugin-standard-gateway.md`
> - 리소스(도구·가이드·템플릿·샘플)가 필요하면 → `resources/plugin-resources.md`
> - 전체 아키텍처 확인이 필요하면 → `standards/plugin-standard.md`

---

## 한 줄 정의

SKILL.md는 사용자 요청을 라우팅하고 에이전트 워크플로우를 오케스트레이션(위임형)하거나
Gateway 도구를 직접 사용(직결형)하는 Controller+UseCase 레이어의 프롬프트 지시문임.

[Top](#skill-표준)

---

## SKILL.md 구조

### Frontmatter 필드

| 필드 | 필수 | 설명 | 예시 |
|------|------|------|------|
| `name` | ✅ | 스킬 ID (kebab-case) | `my-skill` |
| `description` | ✅ | 한 줄 설명 | `코드 품질 분석 스킬` |
| `type` | ✅ | 스킬유형 | core,setup,planning,orchestrator,utility,external |
| `user-invocable` | 선택 | 사용자 직접 호출 가능 여부 (기본값: true) | `true` |
| `disable-model-invocation` | 선택 | 런타임 자동 호출 차단. **주의: `true` 설정 시 스킬 로드 자체가 안 되므로 사용 금지** | `false` |
| `allowed-tools` | 선택 | 허용 도구 목록 | `["Read", "Task"]` |
| `model` | 선택 | 기본 모델 | `sonnet` |
| `context` | 선택 | 컨텍스트 힌트 | `["code-quality"]` |
| `agent` | 선택 | 전용 에이전트 ID | `architect` |

### Markdown Content 골격

```markdown
# {스킬명}

[{스킬명} 활성화]                    ← 선택 (스킬 시작 시 화면에 출력하는 메시지)

## 목표                              ← 필수
(이 스킬이 달성하려는 핵심 목적 1~2문장)

## 활성화 조건                       ← 권장
(이 스킬이 활성화되는 조건)

## 워크플로우                        ← 권장
(단계별 접근법)

### Step 1: 분석                     ← 일반 단계 (위임 없음)
(스킬이 직접 수행하는 작업)

### Step 2: 구현 → Agent: executor   ← Agent 위임 단계 (5항목 필수)
- **TASK**: ...
- **EXPECTED OUTCOME**: ...
- **MUST DO**: ...
- **MUST NOT DO**: ...
- **CONTEXT**: ...

### Step 3: 모드 전환 → Skill: ralph ← Skill 위임 단계 (3항목 필수)
- **INTENT**: ...
- **ARGS**: ...
- **RETURN**: ...
```

[Top](#skill-표준)

---

## 스킬 유형 분류

스킬은 역할에 따라 6가지 유형으로 분류됨.
각 유형은 공통 골격 위에 고유 섹션을 추가하여 정체성을 형성하며, 실행 경로(위임형/직결형)가 유형별로 결정됨.

| 유형 | 영문명 | 실행 경로 | 역할 | 예시 |
|------|--------|----------|------|------|
| 핵심스킬 | Core | 위임형 | 시스템 전체 행동 규범 정의, 항상 활성화 **(필수, 플러그인당 1개)** | core |
| 설정스킬 | Setup | 직결형 | 설치 · 설정 마법사 제공 | omc-setup, mcp-setup |
| 계획스킬 | Planning | 위임형 | 전략적 계획 수립 · 검토 | plan, ralplan, review |
| 지휘자스킬 | Orchestrator | 위임형 | 워크플로우 조율, 병렬 실행, 분석, 리뷰 | autopilot, ralph, analyze, tdd |
| 유틸리티스킬 | Utility | 직결형 | 보조 기능, 상태 제어, 도구, 헬퍼 | note, doctor, help, cancel |
| 외부호출스킬 | External | 외부호출형 | 크로스-플러그인 Skill→Skill 위임으로 외부 플러그인 워크플로우 실행 | ext-{대상플러그인} |

### 스킬 실행 경로

스킬은 유형에 따라 세 가지 실행 경로 중 하나를 따름.

| 실행 경로 | 의미 | 해당 유형 | Agent 계층 |
|----------|------|----------|-----------|
| **위임형** | LLM 추론·자율 판단이 필요한 작업 → Agent에 위임 | Core, Planning, Orchestrator | 경유 (필수) |
| **직결형** | 절차적·결정론적 작업 → Gateway 도구 직접 사용 | Setup, Utility | 생략 |
| **외부호출형** | 크로스-플러그인 Skill→Skill 위임 → 외부 플러그인 워크플로우 실행 | External | 생략 (외부 플러그인이 담당) |

```
위임형:    Skill(Controller) → Agent(Service) → Gateway
직결형:    Skill(Controller) ──────────────────→ Gateway  (Service 생략)
외부호출형: Skill(Controller) → Skill tool → External Plugin's Skill → (외부 워크플로우)
```

**직결형이 필요한 이유 — YAGNI (You Aren't Gonna Need It):**
- Setup/Utility 스킬은 설정 파일 작성, 상태 확인, 도구 설치 등 **결정론적 작업**을 수행
- 이런 작업에 Agent를 경유하면 불필요한 LLM 호출이 발생 (오버 아키텍처링)
- XP(Extreme Programming)의 YAGNI 원칙: "지금 필요하지 않은 기능은 만들지 않는다"
- Agent 계층이 제공하는 자율적 추론은 직결형 스킬에 **필요하지 않은 기능**임

> **스킬 부스팅은 예외**: 직결형 스킬은 Agent 위임을 생략하지만, `→ Skill:` 마커로 OMC 스킬을 호출하는
> 스킬 부스팅은 활용함. 이는 Agent 계층 경유가 아닌 Skill→Skill 호출이므로 직결형 원칙과 충돌하지 않음.

**직결형 스킬의 제약:**
- 애플리케이션 코드 작성·수정은 여전히 금지 — 코드 작업은 반드시 위임형 경로 사용
- 직결형은 설정 파일, 상태 파일, 문서 등 **인프라성 파일**에만 직접 접근

[Top](#skill-표준)

---

## 스킬 활성화 경로

런타임은 세션 시작 시 `skills/` 디렉토리를 스캔하여 모든 스킬을 자동 발견함.
각 스킬은 frontmatter(`name`, `description`)와 `## 활성화 조건` 섹션으로 자기 기술(self-description)하며,
런타임은 이 메타데이터를 기반으로 사용자 요청을 적절한 스킬에 매칭함.

### 활성화 경로 유형

| 경로 | 흐름 | 설명 |
|------|------|------|
| **직접 활성화** | 런타임 → 특정 스킬 | 슬래시 명령(`/plugin:skill`) 또는 자연어 매칭(frontmatter description 기반) |
| **Core 경유 활성화** | 런타임 → Core 스킬 → 특정 스킬 | 모호한 요청으로 복잡한 의도 판별이 필요한 경우, Core 스킬이 라우팅 |

### 직접 활성화

명확한 슬래시 명령 또는 frontmatter의 `description`과 높은 유사도를 보이는 자연어 요청은
런타임이 직접 해당 스킬을 활성화함. 별도의 중간 계층 없이 즉시 스킬이 로드됨.

### Core 경유 활성화

사용자의 요청이 모호하거나 복수 스킬에 걸칠 수 있는 경우,
런타임은 Core 스킬을 먼저 활성화함.
Core 스킬은 요청의 의도를 판별하고 적절한 스킬로 라우팅하는 역할에 한정됨.

> **Core 스킬의 역할 범위**: Core 스킬은 모호한 요청의 **의도 판별 및 라우팅**만 수행함.
> 실제 작업 실행은 라우팅된 대상 스킬(Orchestrator, Planning 등)이 담당함.

[Top](#skill-표준)

---

## 역할 경계 요약

스킬은 **라우터(Router)와 오케스트레이터(Orchestrator)** 역할에 집중함.
직접 작업을 수행하는 것이 아니라, 요청을 분석하고 적절한 에이전트에게 위임하는 것이 핵심 역할임.

| 스킬이 직접 수행 | 에이전트에 위임 (Task 도구) | 다른 스킬에 위임 (Skill 도구) |
|------------------|---------------------------|-------------------------------|
| 요청 의도 분류 (라우팅) | 코드 작성·수정 | 다른 워크플로우 전환 (모드 변경) |
| 워크플로우 분기 결정 | 탐색·분석·조사 | 하위 기능 호출 (setup → hud 등) |
| 사용자 상호작용 (질문, 안내) | 문서 작성 | 독립 스킬의 워크플로우 재활용 |
| 상태 관리 (진행률, 반복 카운트) | 검증·테스트 | 진입점 위임 (commands → skill) |
| 에이전트 결과 취합·보고 | 설계·아키텍처 결정 | — |

> **직결형 스킬 예외**: Setup과 Utility 유형은 직결형 실행 경로를 따르므로,
> 에이전트 위임 없이 Gateway 도구(Read, Write, Bash 등)를 직접 사용함.
> 위 테이블의 "에이전트에 위임" 열은 위임형 스킬(Core, Planning, Orchestrator)에만 적용.

### 위임 대상 판단 기준

| 상황 | 위임 대상 | 도구 | 이유 |
|------|----------|------|------|
| 단일 작업 실행 (코드 작성, 분석 등) | Agent | `Task` | 에이전트가 자율적으로 완수 |
| 다른 워크플로우로 전환 (모드 변경 등) | Skill | `Skill` | 스킬만이 오케스트레이션 로직 보유 |
| 하위 기능 호출 (setup → hud 등) | Skill | `Skill` | 독립된 스킬의 전체 워크플로우 재활용 |
| 사용자 요청 전달 (commands → skill) | Skill | `Skill` | 얇은 wrapper 진입점 |

### 프롬프트 깊이 차등화

스킬이 직접 수행하는 영역과 에이전트에 위임하는 영역은 **프롬프트 작성의 깊이**가 달라야 함:

| 영역 | 프롬프트 깊이 | 작성 지침 |
|------|-------------|-----------|
| **라우팅/분기 로직** | **상세** | 의도 분류 기준, 조건별 분기, 모드 전환 로직을 빠짐없이 기술 |
| **사용자 상호작용** | **상세** | 질문 형식, 응답 처리, 오류 안내 등 UX 흐름을 구체적으로 정의 |
| **에이전트 위임 지시** | **간결** | 목표(WHAT)와 제약(MUST NOT)만 명시, 방법(HOW)은 에이전트에 위임 |
| **상태 관리** | **중간** | 상태 파일 경로·구조는 명시, 세부 로직은 간결하게 |

**핵심**: 스킬 프롬프트가 에이전트의 작업 방법까지 상세히 기술하면 에이전트의 자율성이 떨어지고
유지보수 비용이 증가함. **"무엇을 달성할 것인가"**에 집중하고, **"어떻게 달성할 것인가"**는 에이전트에 맡김.

### 위임 표기법 (Delegation Notation)

워크플로우 단계에서 Agent 또는 Skill에 위임할 때, **단계 제목에 마커**를 붙여 위임을 선언함.
마커가 있는 단계는 해당 위임 유형의 필수 항목을 본문에 반드시 포함해야 함.

**마커 형식:**

| 마커 | 의미 | 필수 항목 | 도구 |
|------|------|----------|------|
| `→ Agent: {name}` | Agent에 작업 위임 | 5항목 | Task |
| `→ Skill: {name}` | 다른 Skill에 위임 | 3항목 | Skill |

#### Agent 위임 5항목 (`→ Agent:`)

```
- **TASK**: 원자적이고 구체적인 목표 (하나의 작업당 하나의 위임)
- **EXPECTED OUTCOME**: 구체적 산출물과 성공 기준
- **MUST DO**: 반드시 수행해야 할 요건 — 빠짐없이 나열
- **MUST NOT DO**: 금지 행위 — 에이전트의 월권 방지
- **CONTEXT**: 파일 경로, 기존 패턴, 제약 조건
```

**간결 원칙**: 위 5항목 외에 에이전트의 내부 사고 방식이나 단계별 절차는 기술하지 않음.
에이전트는 자신의 AGENT.md에 정의된 역할과 워크플로우를 따름.

#### Skill 위임 3항목 (`→ Skill:`)

```
- **INTENT**: 호출 목적 (왜 이 스킬을 호출하는지)
- **ARGS**: 전달 인자 (사용자 입력, 선행 결과 등)
- **RETURN**: 호출 후 기대하는 상태 또는 복귀 조건
```

대상 스킬이 **이미 자체 워크플로우를 보유**하므로, Agent 위임보다 전달 항목이 간결함.

#### 워크플로우 적용 예시

```markdown
## 워크플로우

### Step 1: 요청 분석
사용자 요청의 의도를 분류하고 작업 범위를 결정함.

### Step 2: 코드 탐색 → Agent: explorer
- **TASK**: 대상 모듈의 현재 구조와 의존관계 파악
- **EXPECTED OUTCOME**: 파일 목록, 의존 관계, 수정 영향 범위 보고서
- **MUST DO**: 테스트 파일 포함하여 탐색
- **MUST NOT DO**: 코드 수정 금지
- **CONTEXT**: `src/` 디렉토리 대상

### Step 3: 구현 → Agent: executor (`/oh-my-claudecode:tdd` 활용)
- **TASK**: Step 2의 분석 결과를 기반으로 기능 구현
- **EXPECTED OUTCOME**: 컴파일 에러 없는 구현 코드
- **MUST DO**: 기존 패턴과 일관성 유지
- **MUST NOT DO**: 요청 범위 외 리팩터링 금지
- **CONTEXT**: Step 2의 탐색 결과 참조

### Step 4: QA 전환 → Skill: ultraqa (`/oh-my-claudecode:ultraqa` 활용)
- **INTENT**: 구현 완료 후 QA 사이클 진입
- **ARGS**: 구현된 파일 목록, 테스트 대상
- **RETURN**: 모든 테스트 통과 시 완료
```

#### Skill→Skill 위임 패턴 분류

| 패턴 | 설명 | 예시 |
|------|------|------|
| **하위 기능 호출** | 자기 워크플로우 중 다른 스킬의 기능을 부분적으로 사용 | setup → hud, setup → mcp-setup |
| **모드 전환** | 오케스트레이터가 실행 중 다른 오케스트레이터로 전환 | autopilot → ralph, autopilot → ultraqa |
| **스킬 부스팅** | 워크플로우 단계에서 OMC 스킬을 활용하여 실행 안정성 확보 | setup → ralph, orchestrator → ultraqa |
| **진입점 위임** | commands가 Skill 도구로 스킬에 위임 (얇은 wrapper) | commands/setup.md → abra:setup |

#### Agent 위임과 Skill 위임 비교

| 항목 | `→ Agent:` (Task 도구) | `→ Skill:` (Skill 도구) |
|------|------------------------|--------------------------|
| 필수 항목 | 5항목 | 3항목 |
| HOW 지정 | 금지 (에이전트 자율) | 불필요 (대상 스킬이 자체 워크플로우 보유) |
| 실행 주체 | 서브에이전트로 스폰 | 현재 컨텍스트에서 스킬 로드 |
| 결과 반환 | 에이전트가 결과 텍스트 반환 | 스킬 워크플로우 완료 후 흐름 복귀 |

[Top](#skill-표준)

---

## 에이전트 호출 규칙

위임형 스킬이 `Task` 도구로 에이전트를 호출할 때의 규칙.

### 에이전트 탐색·스폰 흐름

```
1. agents/{agent-name}/ 디렉토리에서 3파일 로드
   ├── AGENT.md       → 프롬프트 본문
   ├── agentcard.yaml → tier 확인 + 프롬프트에 첨부
   └── tools.yaml     → 도구 해석 + 프롬프트에 첨부
2. tier → runtime-mapping.yaml로 모델 매핑
3. 프롬프트 조립: AGENT.md + agentcard.yaml + tools.yaml
4. 인격 주입: agentcard.yaml에 persona가 있으면 프롬프트 앞에 인격 컨텍스트 추가
5. Task(subagent_type=FQN, model=매핑된모델, prompt=조립된 프롬프트) 호출
```

> **프롬프트 조립**: AGENT.md의 "참조" 섹션이 agentcard.yaml과 tools.yaml을 참조하도록 지시하므로,
> 위임형 스킬은 3파일을 합쳐 하나의 프롬프트로 전달함. 에이전트는 자신의 역할·제약·도구를 모두 인식함.

> **매핑 참조**: 위임형 스킬은 `gateway/runtime-mapping.yaml`을 참조하여 tier→모델 매핑을 수행함.
> 에이전트는 runtime-mapping.yaml을 직접 참조하지 않음 — 인프라 매핑은 스킬(Controller)의 책임.

### FQN (정규화된 이름)

런타임이 `agents/` 디렉토리를 재귀 탐색하여 자동 생성하는 전체 이름.

| 형식 | 예시 |
|------|------|
| `{plugin}:{디렉토리명}:{frontmatter-name}` | `abra:architect:architect` |

### 호출 예시

```python
# 위임형 스킬에서 에이전트 호출 예시
Task(
    subagent_type="abra:architect:architect",
    model="opus",        # tier: HIGH → runtime-mapping.yaml에서 매핑
    prompt="시스템 아키텍처를 분석해주세요..."
)
```

> **상세 규칙**: 에이전트 이름 규칙의 전체 내용은 → `standards/plugin-standard-agent.md`의 "에이전트 이름 규칙" 참조.

### 작성 가이드

위임형 스킬(Planning, Orchestrator)의 `## 에이전트 호출 규칙` 섹션에 다음 내용을 포함할 것:

1. **에이전트 FQN 목록** — 이 스킬이 호출하는 에이전트의 FQN (`{plugin}:{agent}:{agent}`)
2. **프롬프트 조립 절차**:
   - `agents/{agent-name}/` 에서 3파일 로드 (AGENT.md + agentcard.yaml + tools.yaml)
   - `gateway/runtime-mapping.yaml` 참조하여 구체화:
     - **모델 구체화**: agentcard.yaml의 `tier` → `tier_mapping`에서 모델 결정
     - **툴 구체화**: tools.yaml의 추상 도구 → `tool_mapping`에서 실제 도구 결정
     - **금지액션 구체화**: agentcard.yaml의 `forbidden_actions` → `action_mapping`에서 제외할 실제 도구 결정
     - **최종 도구** = (구체화된 도구) - (제외 도구)
   - 3파일을 합쳐 하나의 프롬프트로 조립
   - **인격 구체화**: agentcard.yaml에 `persona`가 존재하면,
     프롬프트 앞에 인격 컨텍스트를 주입:
     "당신은 {persona.profile.nickname}입니다. 답변 시 별명 '{persona.profile.nickname}'를 표시하세요. {persona.style} {persona.background}"
   - **프롬프트 구성 순서**: 공통 정적(runtime-mapping) → 에이전트별 정적(3파일) → 인격 주입(persona) → 동적(작업 지시)
     순서로 배치 (런타임의 prefix 캐시 적중률 극대화)
   - `Task(subagent_type=FQN, model=구체화된 모델, prompt=조립된 프롬프트)` 호출

3. **오케스트레이션 스킬 활용** (워크플로우 단계별):

위임형 스킬의 **워크플로우 섹션**에서 오케스트레이터 자신이 OMC 스킬을 활용하여
검증된 방법론으로 서브에이전트들을 오케스트레이션함.
서브에이전트 프롬프트에 스킬 명령을 주입하지 않음 (서브에이전트는 Skill 도구 미보유).

| 워크플로우 단계 | 추천 스킬 | 효과 | 적용 |
|----------------|----------|------|:----:|
| 기획 수립 | `/oh-my-claudecode:plan` | 요구사항 도출 워크플로우 | **필수** |
| 개발 계획 수립 | `/oh-my-claudecode:ralplan` | 기술 합의 워크플로우 | **필수** |
| 기능 구현 | `/oh-my-claudecode:ralph` | 완료 보장 실행 워크플로우 | **필수** |
| 빌드 오류 수정 | `/oh-my-claudecode:build-fix` | 최소 수정 원칙 | **필수** |
| QA/검증 | `/oh-my-claudecode:ultraqa` | QA 순환 워크플로우 | **필수** |
| 계획 검토 | `/oh-my-claudecode:review` | 비평 전문 워크플로우 | **필수** |
| 심층 분석/디버깅 | `/oh-my-claudecode:analyze` | 체계적 분석 절차 | **필수** |
| 코드베이스 탐색 | `/oh-my-claudecode:deepsearch` | 심층 검색 방법론 | **필수** |
| 코드 리뷰 | `/oh-my-claudecode:code-review` | 종합 리뷰 체크리스트 | **필수** |
| 보안 검토 | `/oh-my-claudecode:security-review` | 보안 감사 워크플로우 | **필수** |
| 리서치/조사 | `/oh-my-claudecode:research` | 병렬 조사 방법론 | **필수** |
| *(위 항목에 해당 없음)* | `ulw` 매직 키워드 | 범용 병렬 실행 + 완료 보장 | **필수** |

> **적용 위치**: 스킬의 워크플로우 섹션에 명시.
> 예: `### Phase 2: 계획 수립` → "이 단계는 `/oh-my-claudecode:ralplan`을 활용하여 수행"
>
> **전면 필수**: 모든 워크플로우 단계는 반드시 대응하는 오케스트레이션 스킬을 활용함.
> 위 테이블에 매핑되는 단계가 없을 경우 `ulw` 매직 키워드를 폴백으로 사용하여
> 병렬 실행 + 완료 보장 방법론을 적용함.
>
> **직결형 스킬(Setup, Utility) 적용**: 직결형 스킬도 동일한 스킬 부스팅 테이블을 적용함.
> Agent 위임이 아닌 `→ Skill:` 마커로 OMC 스킬을 호출하여 완료 보장과 오류 복구를 확보함.

[Top](#skill-표준)

---

## 공통 필수 섹션

모든 스킬이 포함해야 할 기본 골격:

| 순서 | 표준 섹션명 | 필수 | 설명 |
|------|------------|------|------|
| 1 | `# {스킬명}` | ✅ | H1 타이틀 + 역할 요약 (한 줄) |
| 2 | `[{스킬명} 활성화]` | 선택 | 스킬 시작 시 화면에 출력하는 메시지 |
| 3 | `## 목표` | ✅ | 이 스킬이 달성하려는 핵심 목적 |
| 4 | `## 활성화 조건` | 권장 | 이 스킬이 활성화되는 조건 · 상황 (자기 선언) |
| 5 | `## 워크플로우` | 권장 | 워크플로우 / 단계별 접근법. 위임 시 `→ Agent:` 또는 `→ Skill:` 마커 사용. <br>위임형 스킬은 모든 단계에 오케스트레이션 스킬 활용 필수 명시 (매핑 없으면 `ulw` 폴백) |
| 6 | `## MUST 규칙` | ✅ | 이 스킬이 반드시 지켜야 할 규칙 목록 (테이블 형식) |
| 7 | `## MUST NOT 규칙` | ✅ | 이 스킬이 절대 해서는 안 되는 금지 사항 (테이블 형식) |
| 8 | `## 검증 체크리스트` | ✅ | 스킬 작성 완료 후 확인할 체크 항목 (`- [ ]` 형식) |

### 섹션명 통일 규칙

동일 목적의 섹션은 표준명 사용 권장:

| 목적 | 표준명 | 비권장 (혼용 사례) |
|------|--------|-------------------|
| 핵심 목적 | `## 목표` | Overview, What It Does, Core Concept, 개요 |
| 활성화 조건 | `## 활성화 조건` | Activation, When to Use, Magic Keywords |
| 워크플로우 | `## 워크플로우` | Workflow, Phases, Approach, Step N |
| 필수 규칙 | `## MUST 규칙` | Rules, 규칙, 준수 사항 |
| 금지 사항 | `## MUST NOT 규칙` | Restrictions, 제한, 금지 |
| 검증 항목 | `## 검증 체크리스트` | Validation, 체크, QA |

### 유형별 활성화 조건 작성 가이드

| 유형 | 활성화 조건 내용 | 예시 |
|------|-----------------|------|
| Core | 광범위 조건 매칭 시 자동 활성화 | "위임이 필요한 작업 감지 시 활성화" |
| Setup | 명시적 호출만 (`/command`) | "사용자가 `/omc-setup` 호출 시" |
| Planning | 키워드 감지 또는 명시적 호출 | "broad request 감지 시 또는 `/plan` 호출 시" |
| Orchestrator | 키워드 감지 + 매직 키워드 | "autopilot, build me, analyze 키워드 감지 시" |
| Utility | 명시적 호출 또는 키워드 감지 | "사용자가 `/note` 호출 시, cancelomc 키워드 감지 시" |
| External | 명시적 호출 또는 키워드 감지 | "외부 플러그인 실행" 키워드 감지 시 또는 `/{plugin}:ext-{대상플러그인}` 호출 시 |

[Top](#skill-표준)

---

## 유형별 필수/권장 섹션

### Core (핵심스킬)

항상 활성화되어 시스템 전체 행동 규범을 정의하는 스킬.

#### 고유 섹션

공통 골격(`# {스킬명}`, `## 목표`, `## 워크플로우` 등)에 더해 Core 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 작업 관리` | 권장 | 작업 관리 규칙 (Todo 생성 기준, 워크플로우) |
| `## 어조와 스타일` | 권장 | 커뮤니케이션 스타일 (간결성, 사용자 맞춤) |
| `## 제약 사항` | 권장 | 소프트 가이드라인 (기존 라이브러리 선호 등) |

#### 워크플로우 작성 패턴

Core 스킬의 `## 워크플로우`는 **라우팅 전용**으로 구성됨.
매 메시지마다 요청 의도를 감지하고 적절한 스킬로 분배하는 흐름을 정의함.

**라우팅 워크플로우 구성:**

| 단계 | 이름 | 설명 |
|------|------|------|
| **Step 1** | 의도 감지 (Intent Detection) | 요청을 분류하는 규칙 정의 (키워드 매칭, 패턴 분석 등) |
| **Step 2** | 스킬 매칭 (Skill Matching) | 분류된 의도를 어떤 스킬에 라우팅할지 조건 테이블로 정의 |
| **Step 3** | 위임 (Dispatch) | 매칭된 스킬에 `→ Skill:` 마커로 위임. 미매칭 시 기본 동작 정의 |

> **Core ≠ Orchestrator**: 실행(현황 파악, 에이전트 위임, 검증, 완료)은 Orchestrator 스킬의 역할.
> Core는 라우팅까지만 수행하고 실행 흐름을 위임된 스킬에 넘김.

#### 특징

- 활성화 조건에 매칭 시 **자동 활성화**
- `{{PROMPT}}` 치환 없음 — 항상 적용되는 행동 규범

[Top](#skill-표준)

---

### Setup (설정스킬)

설치 · 설정 마법사를 제공하는 직결형 스킬.
Agent 위임 없이 Gateway 도구(Bash, Write 등)를 직접 사용.

#### 고유 섹션

공통 골격에 더해 Setup 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 사용자 상호작용` | ✅ | AskUserQuestion으로 사용자 선택지를 UI로 제공하여 분기 |
| `## 스킬 위임` | 권장 | `Skill tool`로 다른 스킬 호출 (예: setup → hud) |
| `## 상태 관리` | 권장 | 상태 파일 기반 중단/재개 복원 |
| `## 문제 해결` | 권장 | 설치 문제 해결 안내 |

#### 워크플로우 작성 패턴

Setup 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.
사용자가 진행 상황을 파악하기 쉽도록 단계별 번호를 부여함.
모든 Step에 대응하는 오케스트레이션 스킬을 필수 명시함 (예: "이 단계는 `/oh-my-claudecode:ralph`를 활용하여 수행").
대응하는 스킬이 없는 Step은 `ulw` 매직 키워드를 폴백으로 명시함.

#### 사용자 발견성 (권장)

플러그인의 사용 가능한 명령과 자동 라우팅 안내는 `help` 유틸리티 스킬로 제공함.
CLAUDE.md 등 런타임 상주 파일에 라우팅 테이블을 등록하는 것은 매 세션 토큰을 소모하므로 권장하지 않음.
help 스킬은 호출 시에만 토큰을 사용하여 효율적임.

#### 특징

- bash 명령어(설치) + Write 도구(설정 파일 작성) 혼합 사용
- 설정 완료 후 검증 단계 포함 권장
- 스킬 부스팅 필수: 워크플로우 단계별 OMC 스킬 활용으로 실행 안정성(완료 보장, 오류 복구) 확보

#### frontmatter 권장 설정

```yaml
---
name: setup
description: 플러그인 초기 설정
type: setup
user-invocable: true
---
```

> **주의**: `disable-model-invocation: true`를 설정하면 런타임이 스킬을 아예 로드하지 않아
> 사용자가 `/my-plugin:setup`으로 호출해도 스킬을 찾을 수 없음.
> Setup 스킬은 `user-invocable: true`만 설정하고 `disable-model-invocation`은 사용하지 않을 것.
> name, description, type은 필수

[Top](#skill-표준)

---

### Planning (계획스킬)

전략적 계획 수립 · 검토를 담당하는 스킬.

#### 고유 섹션

공통 골격에 더해 Planning 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 에이전트 호출 규칙` | ✅ | 에이전트 FQN, 프롬프트 조립, 모델·툴·금지액션 구체화 규칙 |
| `## 품질 기준` | 권장 | 계획 품질 기준 (참조율, 실현 가능성 등) |
| `## 판정 기준` | 권장 | 승인 / 수정 요청 / 반려 판정 기준 |
| `## 계획 저장` | 권장 | 계획 파일 저장 위치 |
| `## 외부 모델 검증` | 선택 | 외부 모델 크로스 검증 프로토콜 |

#### 에이전트 호출 규칙 작성 가이드

상위 "에이전트 호출 규칙 > 작성 가이드"를 따름.

#### 워크플로우 작성 패턴

Planning 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.
모든 Step에 대응하는 오케스트레이션 스킬을 필수 명시함 (예: "이 단계는 `/oh-my-claudecode:ralplan`을 활용하여 수행").
대응하는 스킬이 없는 Step은 `ulw` 매직 키워드를 폴백으로 명시함.

#### 계획 모드 (Planning Mode)

Planning 스킬은 요구사항의 명확도에 따라 세 가지 모드 중 하나로 동작함.
이 모드는 Planning 유형에 한정하지 않고, 사용자 입력을 받아 계획을 수립하는 **모든 스킬**에 적용 가능한 패턴임.

| 모드 | 활성화 조건 | 진행 방식 | 적합한 상황 |
|------|------------|-----------|------------|
| **Interview** | 요구사항이 모호하거나 광범위 (기본값) | 사용자에게 **한 번에 한 질문**씩 순차 질의하여 요구사항 구체화 | "개선해 줘", "리팩터링해 줘" 등 대상·범위가 불명확한 요청 |
| **Direct** | 요구사항이 충분히 구체적 | 인터뷰 생략, **즉시 계획 생성** | 파일·함수·범위가 명시된 상세 요청, `--direct` 플래그 |
| **Consensus** | 복수 관점의 검증이 필요한 복잡한 과제 | 복수 에이전트(예: Planner + Architect + Critic)가 **반복 합의** → 최대 N회 | 아키텍처 결정, 대규모 리팩터링, `--consensus` 플래그 |

각 모드의 핵심 메커니즘:

| 모드 | 핵심 메커니즘 | OMC 참조 구현 |
|------|-------------|--------------|
| **Interview** | AskUserQuestion 도구로 한 번에 한 질문, 질문 전 에이전트로 팩트 선행 조사 (적응형 탐색) | `plan` 스킬 (interview 모드) |
| **Direct** | 주어진 요구사항만으로 계획 생성, 사용자 상호작용 최소화 | `plan --direct` |
| **Consensus** | 에이전트 간 제안 → 검토 → 수정 루프를 합의 도달 시까지 반복 | `ralplan` (`plan --consensus`) |

**모드 선택 가이드**: 요구사항 명확도를 기준으로 자동 판별하되, 사용자가 플래그(`--direct`, `--consensus`)로
명시적 지정도 가능하게 설계함.

#### frontmatter 권장 설정

```yaml
---
name: {skill-name}
description: {skill-description}
type: planning
user-invocable: true
---
```

> **중요**: 사용자가 직접 호출하는 스킬만 user-invocable을 true로 하고 상위 스킬의 워크플로우 일부로만 동작하거나 내부적으로만 사용하는 스킬은 false로 함  
> **주의**: `disable-model-invocation: true` 추가 안함
> name, description, type은 필수

[Top](#skill-표준)

---

### Orchestrator (지휘자스킬)

워크플로우 조율, 병렬 실행, 전문 분석·리뷰를 관리하는 위임형 스킬.
기존 수행자스킬(Executor)의 역할(분석, 리뷰, TDD 등 단일 목적 오케스트레이션)을 포함.

#### 고유 섹션

공통 골격에 더해 Orchestrator 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 에이전트 호출 규칙` | ✅ | 에이전트 FQN, 프롬프트 조립, 모델·툴·금지액션 구체화 규칙 |
| `## 완료 조건` | ✅ | 완료 조건 목록 (기능 동작, 검증 통과, 에러 0 등) |
| `## 검증 프로토콜` | ✅ | 검증 절차 — 완료 전 검증자 승인 강제 |
| `## 상태 정리` | ✅ | 상태 파일 정리 규칙 (완료 시 삭제) |
| `## 취소` / `## 재개` | ✅ | 취소 및 재개 메커니즘 |
| `## 출력 형식` | 권장 | 보고서/출력 텍스트 템플릿 (분석·리뷰 오케스트레이터용) |
| `## 체크리스트` | 선택 | 카테고리별 `- [ ]` 형식 검토 항목 |

#### 에이전트 호출 규칙 작성 가이드

상위 "에이전트 호출 규칙 > 작성 가이드"를 따름.

#### 워크플로우 작성 패턴

Orchestrator 스킬은 `## 워크플로우` 안에 `### Phase N: {Name}` 패턴으로 순차/병렬 단계를 정의함.
각 Phase는 Goal → Agents → Output 구조를 따름.
모든 Phase에 대응하는 오케스트레이션 스킬을 필수 명시함 (예: "이 Phase는 `/oh-my-claudecode:ralph`를 활용하여 수행").
대응하는 스킬이 없는 Phase는 `ulw` 매직 키워드를 폴백으로 명시함.

#### 특징

- 가장 풍부한 구조 (평균 10+ 섹션)
- 검증 프로토콜(Iron Law): "검증 없이 완료 선언 불가" 원칙
- 모드 간 계층 관계 존재 (예: autopilot → ralph → ultrawork)
- 독립 실행 가능 스킬 vs 컴포넌트(단독 불가) 구분

#### frontmatter 권장 설정

```yaml
---
name: {skill-name}
description: {skill-description}
type: orchestrator
user-invocable: true
---
```
> **중요**: 사용자가 직접 호출하는 스킬만 user-invocable을 true로 하고 상위 스킬의 워크플로우 일부로만 동작하거나 내부적으로만 사용하는 스킬은 false로 함  
> **주의**: `disable-model-invocation: true` 추가 안함
> name, description, type은 필수

[Top](#skill-표준)

---

### Utility (유틸리티스킬)

보조 기능, 상태 제어, 도구, 헬퍼, 문서화 등을 제공하는 직결형 스킬.
기존 감독자스킬(Supervisor)의 역할(상태 감시·제어)을 포함.

#### 고유 섹션

공통 골격에 더해 Utility 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 명령어` | ✅ | 명령어 또는 하위 명령어 테이블 |
| `## 참고사항` | 선택 | 필요 시 자유 형식으로 기술 (자동 감지, 연동, 파일 구조, 스키마, 보존 정책 등) |

#### 워크플로우 작성 패턴

Utility 스킬은 `## 워크플로우` 안에 `### Step N: {Name}` 패턴으로 번호 기반 순차 워크플로우를 정의함.

#### 실행 경로

직결형: Gateway 도구(Bash, Read, Write 등)를 직접 사용. Agent 위임 없음.
상태 제어 유틸리티(예: cancel)는 상태 파일 읽기 → 조건 판단 → 파일 삭제/명령 실행의 절차적 흐름.

#### 특징

- **직결형 실행** — Agent 계층을 거치지 않고 Gateway 도구 직접 사용 (YAGNI)
- 가장 간결한 구조 (평균 5 섹션)
- 테이블 중심: 명령어, 옵션, 서브커맨드를 테이블로 정리
- 도메인 특화 가능: 창작, 환경 관리, 배포, 상태 제어 등

#### frontmatter 권장 설정

```yaml
---
name: {skill-name}
description: {skill-description}
type: utility
user-invocable: true
---
```

> **중요**: 사용자가 직접 호출하는 스킬만 user-invocable을 true로 하고 상위 스킬의 워크플로우 일부로만 동작하거나 내부적으로만 사용하는 스킬은 false로 함  
> **주의**: `disable-model-invocation: true` 추가 안함
> name, description, type은 필수

[Top](#skill-표준)

---

### External (외부호출스킬)

크로스-플러그인 Skill→Skill 위임으로 외부 플러그인의 워크플로우를 실행하는 스킬.
자체 Agent를 보유하지 않고, Skill 도구를 통해 외부 플러그인의 스킬에 작업을 위임함.

#### 고유 섹션

공통 골격에 더해 External 고유 섹션:

| 섹션 | 필수 | 설명 |
|------|------|------|
| `## 선행 요구사항` | ✅ | 외부 플러그인 설치 확인 방법 및 미설치 시 안내 |
| `## 크로스-플러그인 스킬 위임 규칙` | ✅ | 외부 스킬 FQN, 입력 전달 규약, 경로 분기 |
| `## 도메인 컨텍스트 수집` | ✅ | **플러그인 명세서**의 "도메인 컨텍스트 수집 가이드"를 참조하여 수집 대상 결정 |
| `## 경로 분기` | 권장 | **플러그인 명세서**에 정의된 실행 경로 중 조건에 따라 선택 |
| `## 완료 조건` | ✅ | 외부 스킬 워크플로우 완료 판단 기준 |
| `## 검증 프로토콜` | ✅ | 산출물 존재 및 품질 검증 절차 |
| `## 상태 정리` | ✅ | 상태 파일 정리 규칙 |
| `## 취소` / `## 재개` | ✅ | 취소 및 재개 메커니즘 |

#### 워크플로우 작성 패턴

External 스킬은 `## 워크플로우` 안에 `### Phase N: {Name}` 패턴으로 순차 단계를 정의함.
각 Phase는 도메인 컨텍스트 수집 → 경로 분기 → 외부 스킬 위임 → 결과 검증 구조를 따름.

**표준 워크플로우 구조:**

| Phase | 이름 | 설명 |
|-------|------|------|
| Phase 0 | 선행 확인 | 외부 플러그인 설치 확인, 미설치 시 안내 |
| Phase 1 | 도메인 컨텍스트 수집 | 플러그인 명세서의 "도메인 컨텍스트 수집 가이드"에 따라 수집 |
| Phase 2 | 경로 분기 결정 | 수집된 컨텍스트로 플러그인 명세서의 실행 경로 중 하나를 결정 |
| Phase 3+ | 외부 스킬 위임 | `→ Skill:` 마커로 외부 플러그인 스킬에 위임 (3항목 필수) |
| 최종 Phase | 결과 검증 및 보고 | 산출물 검증 후 사용자에게 완료 보고 |

#### Skill→Skill 입력 전달 규약

크로스-플러그인 Skill→Skill 위임 시, 호출자 스킬이 대상 스킬의 Phase 0(사용자 입력 수집)에
필요한 입력을 JSON 구조의 `ARGS` 루트 키로 전달함.

**ARGS 구조:**

```json
ARGS: {
  "source_plugin": "{호출자 플러그인명}",
  "{key1}": "{value1}",
  "{key2}": "{value2}"
}
```

**규약:**

| # | 규칙 | 설명 |
|---|------|------|
| 1 | 호출 판별 | `ARGS` 루트 키 존재 시 plugin-to-plugin 호출로 간주 |
| 2 | 사용자 호출 구분 | `ARGS` 키 미존재 시 사용자 직접 호출 → AskUserQuestion으로 입력 수집 |
| 3 | 사전 제공 항목 스킵 | `ARGS` 내부에 값이 존재하는 항목은 Phase 0에서 사용자에게 질문하지 않음 |
| 4 | 전체 스킵 | 모든 필수 항목이 `ARGS`에 포함된 경우 Phase 0 전체를 스킵 |
| 5 | 부분 스킵 | 일부만 포함된 경우 미포함 항목만 사용자에게 질문 |
| 6 | 컨텍스트 공유 | Skill→Skill 위임은 동일 대화 컨텍스트에서 실행되므로 파일/이미지 접근 가능 |

**대상 스킬 구현 패턴:**

대상 스킬(외부 플러그인)의 Phase 0에 다음 구조를 추가:

> **`#### Skill→Skill 사전 입력 처리`**
>
> `ARGS` 루트 키 존재 시 plugin-to-plugin 호출로 판별하고, 내부 값을 사용:
>
> | ARGS 내부 키 | 대응 Phase 0 항목 | 동작 |
> |-------------|-------------------|------|
> | `source_plugin` | — | 호출자 플러그인 식별 |
> | `{key}` | {항목명} | 질문 스킵, 제공된 값 사용 |
>
> `ARGS` 키 미존재 시 사용자 직접 호출로 판별하고, AskUserQuestion으로 입력 수집.

#### 특징

- **Agent 미보유**: 자체 에이전트 없이 Skill 도구로 외부 플러그인에 위임
- **도메인 컨텍스트 브릿지**: 플러그인 명세서의 수집 가이드에 따라 메타데이터를 수집하여 외부 플러그인에 전달
- **경로 분기**: 플러그인 명세서의 실행 경로 정의에 따라 조건별로 외부 스킬 호출 경로를 분기
- **선행 요구사항 필수**: 외부 플러그인 설치 여부를 Phase 0에서 반드시 확인
- 스킬 부스팅 적용: 직접 수행 단계에 `ulw` 매직 키워드 폴백 적용

#### frontmatter 권장 설정

```yaml
---
name: ext-{대상플러그인}
description: 외부 플러그인 위임으로 {대상플러그인} 워크플로우 실행
type: external
user-invocable: true
---
```

> **주의**: `disable-model-invocation: true` 추가 안함
> name, description, type은 필수

[Top](#skill-표준)

---

## 공통 선택 섹션

복잡도에 따라 선택적으로 추가:

| 섹션 | 권장 시기 | 설명 |
|------|-----------|------|
| `## 외부 모델 검증` | 외부 AI 모델 활용 시 | Codex, Gemini 등 크로스 검증 프로토콜 |
| `## 문제 해결` | 실패 가능성 높은 스킬 | 문제 해결 안내 |
| `## 예시` | 복잡한 사용법 스킬 | 시나리오별 사용 예시 |
| `## 모범 사례` | 오용 가능성 있는 스킬 | 모범 사례 / 안티패턴 |
| `## 아키텍처` | 복잡한 시스템 스킬 | ASCII 아키텍처 다이어그램 |
| `## 상태 관리` | 상태 파일 사용 스킬 | 상태 파일 위치 + JSON 구조 |
| `## 매직 키워드` | 자동 활성화 지원 스킬 | 트리거 키워드 목록 |
| `## 에러 처리` | 실패 복구 필요 스킬 | 에러 유형별 대응 전략 |

[Top](#skill-표준)

---

## 표준 템플릿

### Core 유형 템플릿

```markdown
---
name: my-core-skill
description: 시스템 전체 행동 규범
type: core
user-invocable: false
---

# My Core Skill

[MY-CORE-SKILL 활성화]

## 목표

시스템 전체에 항상 적용되는 행동 규범을 정의함.

## 활성화 조건

광범위 조건 매칭 시 자동 활성화.

## 워크플로우

### Step 1: 의도 감지

요청의 키워드, 패턴, 맥락을 분석하여 의도를 분류함.

### Step 2: 스킬 매칭

| 의도 | 매칭 스킬 |
|------|----------|
| "build me", "autopilot" | autopilot |
| "plan this", broad request | plan |
| ... | ... |

### Step 3: 위임 → Skill: {매칭된 스킬}

- **INTENT**: 분류된 의도에 맞는 스킬 활성화
- **ARGS**: 사용자 요청 원문 전달
- **RETURN**: 스킬 워크플로우 완료 후 사용자에게 결과 보고

미매칭 시 기본 Orchestrator로 라우팅.

## 작업 관리

Todo 생성 기준 및 워크플로우.

## 어조와 스타일

커뮤니케이션 스타일 (간결성, 사용자 맞춤).

## 제약 사항

소프트 가이드라인 (기존 라이브러리 선호 등).

## MUST 규칙

| # | 규칙 |
|---|------|
| 1 | {이 스킬 고유의 필수 규칙} |

## MUST NOT 규칙

| # | 금지 사항 |
|---|----------|
| 1 | {이 스킬 고유의 금지 사항} |

## 검증 체크리스트

- [ ] {이 스킬 고유의 검증 항목}
```

### Orchestrator 유형 템플릿

```markdown
---
name: my-orchestrator
description: 워크플로우 조율 및 병렬 실행 관리
type: orchestrator
user-invocable: true|false
---
> **중요**: 사용자가 직접 호출하는 스킬만 user-invocable을 true로 하고 상위 스킬의 워크플로우 일부로만 동작하거나 내부적으로만 사용하는 스킬은 false로 함

# My Orchestrator

[MY-ORCHESTRATOR 활성화]

## 목표

워크플로우 조율 및 병렬 실행을 관리하는 지휘자 스킬.

## 활성화 조건

"keyword" 키워드 감지 시 또는 `/my-orchestrator` 호출 시.

## 에이전트 호출 규칙

### 에이전트 FQN

| 에이전트 | FQN |
|----------|-----|
| executor | `my-plugin:executor:executor` |
| architect | `my-plugin:architect:architect` |

### 프롬프트 조립

1. `agents/{agent-name}/` 에서 3파일 로드 (AGENT.md + agentcard.yaml + tools.yaml)
2. `gateway/runtime-mapping.yaml` 참조하여 구체화:
   - **모델 구체화**: agentcard.yaml의 `tier` → `tier_mapping`에서 모델 결정
   - **툴 구체화**: tools.yaml의 추상 도구 → `tool_mapping`에서 실제 도구 결정
   - **금지액션 구체화**: agentcard.yaml의 `forbidden_actions` → `action_mapping`에서 제외할 실제 도구 결정
   - **최종 도구** = (구체화된 도구) - (제외 도구)
3. 프롬프트 조립: AGENT.md + agentcard.yaml + tools.yaml을 합쳐 하나의 프롬프트로 구성
   - **구성 순서**: 공통 정적(runtime-mapping) → 에이전트별 정적(3파일) → 동적(작업 지시)
4. `Task(subagent_type=FQN, model=구체화된 모델, prompt=조립된 프롬프트)` 호출

## 워크플로우

### Phase 1: 초기화

상태 파일 생성, 설정 로드.

### Phase 2: 실행 → Agent: executor (`/oh-my-claudecode:tdd` 활용)

- **TASK**: 기능 구현
- **EXPECTED OUTCOME**: 컴파일 에러 없는 구현 코드
- **MUST DO**: 기존 패턴 일관성 유지
- **MUST NOT DO**: 요청 범위 외 수정 금지
- **CONTEXT**: Phase 1에서 로드한 설정 참조

### Phase 3: 검증 → Agent: architect

- **TASK**: 구현 결과 검증
- **EXPECTED OUTCOME**: 승인(APPROVED) 또는 수정 요청(REJECTED + 사유)
- **MUST DO**: 빌드·테스트 통과 확인, 코드 품질 검토
- **MUST NOT DO**: 직접 코드 수정 금지
- **CONTEXT**: Phase 2 구현 결과물

### Phase 4: 완료

상태 정리 및 사용자 보고.

## 완료 조건

- [ ] 기능 동작 확인
- [ ] 검증 통과
- [ ] 에러 0

## 검증 프로토콜

완료 전 Architect 승인 필수.

## 상태 정리

완료 시 `.omc/state/my-orchestrator-state.json` 삭제.

## 취소

`cancelomc` 또는 `stopomc` 키워드로 취소.

## 재개

`resume-session` 도구로 재개 가능.

## MUST 규칙

| # | 규칙 |
|---|------|
| 1 | {이 스킬 고유의 필수 규칙} |

## MUST NOT 규칙

| # | 금지 사항 |
|---|----------|
| 1 | {이 스킬 고유의 금지 사항} |

## 검증 체크리스트

- [ ] {이 스킬 고유의 검증 항목}
```

### Utility 유형 템플릿 (help 스킬 예시)

~~~markdown
---
name: help
description: 플러그인 사용 안내
type: utility
user-invocable: true
---

# Help

[HELP 활성화]

## 목표

플러그인의 사용 가능한 명령, 자동 라우팅 규칙, 주요 기능을 안내함.
런타임 상주 파일(CLAUDE.md)에 라우팅 테이블을 등록하는 대신,
이 스킬이 호출 시에만 토큰을 사용하여 사용자 발견성을 제공함.

## 활성화 조건

사용자가 `/my-plugin:help` 호출 시 또는 "도움말", "뭘 할 수 있어" 키워드 감지 시.

## 워크플로우

**중요: 추가적인 파일 탐색이나 에이전트 위임 없이, 아래 내용을 즉시 사용자에게 출력하세요.**

### 사용 가능한 명령

| 명령 | 설명 |
|------|------|
| `/my-plugin:setup` | 플러그인 초기 설정 |
| `/my-plugin:help` | 사용 안내 |

### 자동 라우팅

- "키워드 A" → skill-a 스킬
- "키워드 B" → skill-b 스킬

## MUST 규칙

| # | 규칙 |
|---|------|
| 1 | {이 스킬 고유의 필수 규칙} |

## MUST NOT 규칙

| # | 금지 사항 |
|---|----------|
| 1 | {이 스킬 고유의 금지 사항} |

## 검증 체크리스트

- [ ] {이 스킬 고유의 검증 항목}
~~~

### External 유형 템플릿

```markdown
---
name: ext-{대상플러그인}
description: 외부 플러그인 위임으로 {대상플러그인} 워크플로우 실행
type: utility
user-invocable: true
---

# Build Service

[BUILD-SERVICE 활성화]

## 목표

외부 플러그인의 워크플로우를 활용하여 서비스를 빌드함.
도메인 컨텍스트를 수집하고 적절한 경로를 분기하여 외부 스킬에 위임.

## 선행 요구사항

{외부 플러그인명} 플러그인이 설치되어 있어야 함.

확인: `claude plugin list`
설치: `claude plugin marketplace add {org}/{plugin}`, `claude plugin install {plugin}@{marketplace}`

## 활성화 조건

사용자가 `/{plugin}:ext-{대상플러그인}` 호출 시 또는 "외부 플러그인 실행" 키워드 감지 시.

## 크로스-플러그인 스킬 위임 규칙

> **스킬 목록 결정**: 대상 플러그인 명세서의 "제공 스킬" 섹션을 참조하여 위임할 스킬 FQN 결정.

| 외부 스킬 | FQN | 용도 |
|----------|-----|------|
| {명세서의 스킬 1} | `{명세서의 FQN 1}` | {명세서의 설명 1} |
| {명세서의 스킬 2} | `{명세서의 FQN 2}` | {명세서의 설명 2} |

## 도메인 컨텍스트 수집

> **수집 대상 결정**: 대상 플러그인 명세서(`resources/plugins/{분류}/{name}.md`)의
> "도메인 컨텍스트 수집 가이드" 섹션을 로드하여 수집 대상 테이블을 그대로 사용.

| 수집 대상 | 소스 | 용도 |
|----------|------|------|
| {명세서의 수집 대상 1} | {명세서의 소스 1} | {명세서의 용도 1} |
| {명세서의 수집 대상 2} | {명세서의 소스 2} | {명세서의 용도 2} |
| ... | ... | ... |

## 워크플로우

### Phase 0: 선행 확인 (`ulw` 활용)

외부 플러그인 설치 확인. 미설치 시 사용자에게 설치 안내.

### Phase 1: 도메인 컨텍스트 수집 (`ulw` 활용)

도메인 컨텍스트 수집 테이블에 따라 메타데이터, 요구사항, 참고 자료를 수집.

### Phase 2: 경로 분기 결정

수집된 컨텍스트를 기반으로 실행 경로를 결정.

> **경로 결정**: 대상 플러그인 명세서의 "실행 경로" 섹션을 로드하여 조건·경로명·스킬 체인을 참조.

| 조건 | 경로 | 외부 스킬 |
|------|------|----------|
| {명세서의 조건 1} | {명세서의 경로명 1} | {명세서의 스킬 체인 1} |
| {명세서의 조건 2} | {명세서의 경로명 2} | {명세서의 스킬 체인 2} |

### Phase 3: 외부 스킬 위임 → Skill: {external-skill}

- **INTENT**: {위임 목적}
- **ARGS**: {
    "source_plugin": "{플러그인명}",
    ...대상 플러그인 명세서의 "ARGS 스키마 > {대상 스킬명} 스킬 ARGS" 섹션에
    정의된 키-값 쌍을 Phase 1에서 수집한 값으로 채움
  }
- **RETURN**: {기대 결과}

### Phase 4: 결과 검증 및 보고 (`ulw` 활용)

산출물 존재 및 품질 검증 후 사용자에게 완료 보고.

## 완료 조건

- [ ] 외부 플러그인 설치 확인
- [ ] 도메인 컨텍스트 수집 완료
- [ ] 외부 스킬 위임 및 워크플로우 완료
- [ ] 산출물 존재 확인

## 검증 프로토콜

산출물 파일 존재 확인 및 내용 검증.

## 상태 정리

완료 시 임시 파일 없음 (상태 파일 미사용).

## 취소

사용자가 "cancelomc" 또는 "stopomc" 요청 시 즉시 중단.

## 재개

마지막 완료된 Phase부터 재시작 가능.

## 스킬 부스팅

| 단계 | OMC 스킬 | 목적 |
|------|----------|------|
| Phase 0~1 | `ulw` 매직 키워드 | 수집 작업의 병렬 실행 + 완료 보장 |
| Phase 4 | `ulw` 매직 키워드 | 검증 + 보고의 완료 보장 |

## MUST 규칙

| # | 규칙 |
|---|------|
| 1 | 외부 플러그인 설치 여부를 Phase 0에서 반드시 확인 |
| 2 | 도메인 컨텍스트 수집을 완료한 후 외부 스킬에 위임 |
| 3 | Skill→Skill 입력 전달 규약을 준수하여 ARGS 전달 |
| 4 | 경로 분기 조건을 명확히 정의 |

## MUST NOT 규칙

| # | 금지 사항 |
|---|----------|
| 1 | 외부 플러그인의 내부 워크플로우를 직접 실행하지 않음 (Skill 도구로 위임) |
| 2 | 자체 Agent를 생성하지 않음 (외부 플러그인이 Agent 보유) |
| 3 | 외부 플러그인의 산출물을 임의로 수정하지 않음 |

## 검증 체크리스트

- [ ] 선행 요구사항 섹션에 외부 플러그인 설치 확인 방법이 기술되어 있는가
- [ ] 크로스-플러그인 스킬 위임 규칙에 외부 스킬 FQN이 명시되어 있는가
- [ ] 도메인 컨텍스트 수집 대상이 테이블로 정리되어 있는가
- [ ] 경로 분기 조건이 명확히 정의되어 있는가
- [ ] Skill→Skill 입력 전달 규약이 적용되어 있는가
- [ ] 워크플로우의 모든 직접 수행 단계에 스킬 부스팅이 명시되어 있는가
- [ ] 대상 플러그인 명세서(`resources/plugins/{분류}/{name}.md`)가 존재하는가
```

[Top](#skill-표준)

---

## MUST 규칙

| # | 규칙 | 근거 |
|---|------|------|
| 1 | YAML Frontmatter(name, description) + Markdown Content 구조 유지 | 메타데이터/프롬프트 분리 |
| 2 | H1 타이틀 + 목표 공통 골격 포함 (활성화 조건, 워크플로우는 권장) | 스킬 간 일관성 |
| 3 | 에이전트 위임 시 WHAT+제약만 명시, HOW는 에이전트에 맡김 | 에이전트 자율성 보장 |
| 4 | 워크플로우에서 `→ Agent:` 마커 사용 시 5항목, `→ Skill:` 마커 사용 시 3항목 포함 | 위임 품질 보장 |
| 5 | 라우팅/분기 로직은 상세히, 에이전트 위임은 간결하게 | 프롬프트 깊이 차등화 |
| 6 | 섹션명 한글 표준명 사용 (목표, 활성화 조건, 워크플로우) | 스킬 간 일관성 |
| 7 | 위임형 및 Setup 스킬: 모든 워크플로우 단계에서 오케스트레이션 스킬 활용 필수 명시. 매핑 스킬이 없으면 `ulw` 폴백 | 검증된 방법론 주입 |
| 8 | 위임형 스킬: 프롬프트 구성 순서를 공통 정적 → 에이전트별 정적 → 동적 순서로 배치 | prefix 캐시 최적화 |

[Top](#skill-표준)

---

## MUST NOT 규칙

| # | 금지 사항 | 이유 |
|---|----------|------|
| 1 | 스킬이 직접 애플리케이션 코드 작성·수정·삭제 (직결형 스킬의 설정 파일·문서 작업은 예외) | 에이전트 역할 침범 |
| 2 | 에이전트 위임 시 내부 사고 방식·단계별 절차 기술 | 에이전트 자율성 저해 |
| 3 | `→ Agent:` 위임 시 5항목, `→ Skill:` 위임 시 3항목 외 추가 기술 | 간결 원칙 위반 |
| 4 | 비표준 섹션명 사용 (Overview 대신 목표 사용) | 일관성 저해 |

[Top](#skill-표준)

---

## 검증 체크리스트

- [ ] Frontmatter에 name, description, type 포함
- [ ] H1 타이틀 존재
- [ ] 목표 섹션 존재
- [ ] 유형에 맞는 고유 섹션 포함
- [ ] 실행 경로가 유형에 맞는가 (위임형: Core/Planning/Orchestrator, 직결형: Setup/Utility, 외부호출형: External)
- [ ] 위임형 스킬: `→ Agent:` 마커가 있는 워크플로우 단계에 5항목이 포함되는가
- [ ] 위임형 스킬: `→ Skill:` 마커가 있는 워크플로우 단계에 3항목이 포함되는가
- [ ] 직결형 스킬: Agent 위임 없이 Gateway 도구를 직접 사용하는가 (YAGNI)
- [ ] 직결형 스킬: 애플리케이션 코드 작성·수정을 하지 않는가 (설정 파일·문서만 허용)
- [ ] 위임 프롬프트에 HOW(방법) 없이 WHAT(목표)+제약만 기술했는가
- [ ] 라우팅 로직은 상세하게, 위임은 간결하게 작성했는가
- [ ] Core 스킬: 워크플로우가 라우팅 전용인가 (실행 Phase 없음)
- [ ] Setup 스킬: `disable-model-invocation: true`를 사용하지 않았는가 (사용 시 스킬 로드 불가)
- [ ] Setup 스킬: help 유틸리티 스킬 제공 여부 (권장)
- [ ] Setup 스킬: 워크플로우 단계에 스킬 부스팅이 명시되었는가
- [ ] 섹션명이 한글 표준명을 사용하는가 (목표, 활성화 조건, 워크플로우)
- [ ] commands/ 진입점 파일 작성 (슬래시 명령 노출 시)
- [ ] 위임형 스킬(Planning, Orchestrator): 에이전트 호출 규칙 섹션 포함
- [ ] Orchestrator 스킬: 완료 조건, 검증 프로토콜, 상태 정리, 취소/재개 섹션 포함
- [ ] External 스킬: 선행 요구사항, 크로스-플러그인 스킬 위임 규칙, 도메인 컨텍스트 수집 섹션 포함
- [ ] External 스킬: 경로 분기가 정의되어 있는가
- [ ] External 스킬: Skill→Skill 입력 전달 규약이 적용되어 있는가
- [ ] 위임형 및 Setup 스킬: 모든 워크플로우 단계에 오케스트레이션 스킬 활용이 명시되었는가
- [ ] 위임형 및 Setup 스킬: 매핑 스킬이 없는 단계에 `ulw` 폴백이 적용되었는가
- [ ] 위임형 스킬: 프롬프트 구성 순서가 공통 정적 → 에이전트별 정적 → 동적 순서인가
- [ ] `## MUST 규칙` 섹션이 파일 마지막 3개 섹션 중 첫 번째에 위치하는가
- [ ] `## MUST NOT 규칙` 섹션이 `## MUST 규칙` 바로 다음에 위치하는가
- [ ] `## 검증 체크리스트` 섹션이 파일의 최종 섹션인가

[Top](#skill-표준)
